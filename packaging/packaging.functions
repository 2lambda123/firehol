#!/bin/bash

get_staged_file() {
  local dir="${1%/*}"
  if [ "$dir" = "$1" ]; then dir="."; fi
  mkdir -p $MYTMP/files/$dir
  if [ "$from_cache" ]
  then
    test -f $MYTMP/files/$1 || git show :$1 > $MYTMP/files/$1
  else
    test -f $MYTMP/files/$1 || cp $1 $MYTMP/files/$1
  fi
}

try_build() {
  if [ -f $MYTMP/success ]; then return 0; fi
  mkdir -p $MYTMP/build
  git archive HEAD | tar -xf - -C "$MYTMP/build"
  git diff --staged | patch -p1 -d "$MYTMP/build"
  (cd $MYTMP/build; ./packaging/git-build || touch $MYTMP/fail)
  if [ -f $MYTMP/fail ]; then return 1; fi
  (cd $MYTMP/build; ./packaging/tar-compare . *.tar.gz || touch $MYTMP/fail)
  if [ -f $MYTMP/fail ]; then return 1; fi
  touch $MYTMP/success
  return 0
}

get_changelog_version() {
  get_staged_file ChangeLog
  local v=`sed -ne '1s/.*(\(.*\)).*/\1/p' $MYTMP/files/ChangeLog`
  if [ ! "$v" ]; then v="No version in ChangeLog!"; fi
  echo "$v"
}

get_configure_ac_version() {
  get_staged_file configure.ac
  local v=`sed -n \
         -e '/define(\[VERSION_\(MINOR\|FIX\)/s/.*\[\([^[]*\)\].*/.\1/p' \
         -e '/define(\[VERSION_\(MAJOR\|SUFFIX\)/s/.*\[\([^[]*\)\].*/\1/p' \
         $MYTMP/files/configure.ac | tr -d '\n'`
  if [ ! "$v" ]; then v="No version in configure.ac!"; fi
  echo "$v"
}

splitver() {
	local maj min fix sfx IFS=.-_

	maj=$1
	min=$2
	fix=$3
	sfx=$4

	set -- $5
	eval $maj=\$1 $min=\$2 $fix=\$3
}

match_version() {
  case "$1" in
     [0-9]*.[0-9]*.[0-9]*_*)
       # x.y.z_ZZZZ = development branch (can be before or after pre/rc)
       echo "development"
     ;;
     [0-9]*.[0-9]*.[0-9]-pre[0-9]*)
       echo "prerelease"
     ;;
     [0-9]*.[0-9]*.[0-9]-rc.[0-9]*)
       echo "candidate"
     ;;
     [0-9]*.[0-9]*.[0-9]*)
       echo "release"
     ;;
     *)
       # Unknown
       :
     ;;
  esac
}

check_versions() {
  local status=0 exact=0 prerelease=0

  if [ -f $MYTMP/version-checked ]
  then
    read status < $MYTMP/version-checked
    return $status
  fi

  local confver=`get_configure_ac_version`
  case "$(match_version $confver)" in
     development)
       :
     ;;
     prerelease|candidate|release)
       exact=1
     ;;
     *)
       echo "Unrecognised version in configure.ac ($confver)"
       status=1
     ;;
  esac

  local clogver=`get_changelog_version`
  case "$(match_version $clogver)" in
     development)
       echo "Do not include development branch version in ChangeLog ($clogver)"
       status=1
     ;;
     prerelease|candidate)
       prerelease=1
     ;;
     release)
       :
     ;;
     *)
       echo "Unrecognised version format in ChangeLog ($clogver)"
       status=1
     ;;
  esac

  if [ $status -eq 0 -a $exact -eq 0 ]
  then
    local clogmaj clogmin clogfix clogsfx
    local confmaj confmin conffix confsfx

    splitver clogmaj clogmin clogfix clogsfx "$clogver"
    splitver confmaj confmin conffix confsfx "$confver"

    if [ $confmaj -gt $clogmaj \
      -o $confmin -gt $clogmin \
      -o $conffix -gt $clogfix ]
    then
      :
    elif [ $confmaj -eq $clogmaj \
        -a $confmin -eq $clogmin \
        -a $conffix -eq $clogfix \
        -a $prerelease -eq 1 ]
    then
      :
    else
      echo "Version in configure.ac ($confver) lesser than ChangeLog ($clogver)"
      status=1
    fi
  fi

  if [ $exact -eq 1 ]
  then
    echo "Running additional release checks"

    if [ "$confver" != "$clogver" ]
    then
      echo "Version in configure.ac ($confver) differs from ChangeLog ($clogver)"
      status=1
    elif [ "$(git tag -l v$confver)" ]
    then
      echo "Tag v$confver already exists"
      status=1
    fi

    if [ "$(git config user.signingkey)" = "" ]
    then
      echo "You need to set up a PGP signing key e.g.:"
      echo "   gpg --list-keys"
      echo "and"
      echo "   git config user.signingkey SHORTID"
      echo "or"
      echo "   git config --global user.signingkey SHORTID"
      status=1
    fi

    git status -s | grep "^?" > $MYTMP/needclean
    if [ -s $MYTMP/needclean ]
    then
      echo "The following files must be dealt with before commit:"
      cat $MYTMP/needclean
      echo "e.g. add them to .gitignore or remove with 'git clean -fdx'"
      status=1
    fi
  fi

  echo $status > $MYTMP/version-checked
  return $status
}

check_commands() {
  local status=0

  touch $MYTMP/commands-checked
  if grep -q -F -z "$1" $MYTMP/commands-checked
  then
    # Only check a file once - an edit to some files checks multiple
    return 0
  else
    echo "$1" >> $MYTMP/commands-checked
  fi

  get_staged_file $1
  get_staged_file configure.ac
  get_staged_file sbin/commands.sed.in
  get_staged_file sbin/functions.common.sh

  # Find commands that have been enclosed in quotes and remove anything after
  #  if nothing matched the substitution, proceed to the next line
  #  if the command is used in a -z check, proceed to the next line
  #  if the command is in posix size check [ "$var" ], proceed to the next line
  #  if the command is being assigned to a variable, proceed to the next line
  #  if the command is being used in an eval, proceed to the next line
  # Anything left, print the line number
  sed -n -e 's/.*\([(`|&][^)`]*"\$[^("}]*_CMD}*\).*/\1/' \
         -e 's/^[ 	]*\("\$[^("}]*_CMD}*\)/\1/' \
         -e T \
         -e '/-z *"\$/b' \
         -e '/\[ *"\$/b' \
         -e '/= *"\$/b' \
         -e '/eval *"\$/b' \
         -e '{=}' \
         $MYTMP/files/$1 > $MYTMP/errors
  if [ -s $MYTMP/errors ]
  then
    status=1
    echo "Detected use(s) of \"\${SOMETHING_CMD}\" in ${1}. Check lines:"
    cat $MYTMP/errors
  fi

  # Ignore lines from the command table and require_cmd entries
  # ensure at least 2 characters before and after each word, reset cond jump
  # extract the command and immediate surroundings, got to next line if no match
  # remove brackets
  # proceed to next line if command starts with a dollar
  # proceed to next line if command ends with equals (assignment)
  # print line number
  sed -n -e '/^	*[YN]|/b' -e '/require_cmd/b' \
         -e 's/^/  /' -e 's/$/  /' -e T \
         -e 's/.*\(..\<[A-Z0-9_]*_CMD..\).*/\1/' -e T \
         -e 's/[{}]//' \
         -e '/$[A-Z]/b' \
         -e '/[A-Z0-9]=/b' \
         -e '=' \
         $MYTMP/files/$1 > $MYTMP/errors
  if [ -s $MYTMP/errors ]
  then
    status=1
    echo "Detected use(s) of 'SOMETHING_CMD' (missing \$) in ${1}. Check lines:"
    cat $MYTMP/errors
  fi

  sed -n -e "s/^	*[YN]|//p" $MYTMP/files/$1 > $MYTMP/commands-defined
  for cmd in $(tr " " "\n" < $MYTMP/files/$1 |
             sed -n -e 's/.*\(\<[A-Z0-9_]*\)_CMD.*/\1/p' | sort | uniq)
  do
    if ! grep -q "^${cmd}_CMD|" $MYTMP/commands-defined
    then
      status=1
      echo "Missing definition of $cmd in $1 detection table."
    fi

    # Hostname is a special case - configure will expand it to running host,
    # overwriting the value we wanted to use.
    if [ "$cmd" = "HOSTNAME" ]; then cmd="HOSTNAMECMD"; fi
    if ! grep -q "_${cmd}(\|\[$cmd\]" $MYTMP/files/configure.ac
    then
      status=1
      echo "Missing detection of $cmd for $1 in configure.ac"
    fi
  done

  while IFS="|" read cmd subst defaults
  do
    if ! grep -q "\${*$cmd" $MYTMP/files/$1 $MYTMP/files/sbin/*.sh
    then
      status=1
      echo "$cmd detected but never used in $1 or function libraries"
    fi
    if ! grep -q "#$subst#" $MYTMP/files/sbin/commands.sed.in
    then
      status=1
      echo "$cmd detected but $subst never substituted by sbin/commands.sed.in"
    fi
  done < $MYTMP/commands-defined

  (
   a=`pwd`
   cd $MYTMP/files
   $a/packaging/detect-cmd.pl configure.ac $1 || touch $MYTMP/detect
  )
  if [ -f $MYTMP/detect ]; then status=1; fi

  return $status
}

check_changelog() {
  local status=0

  get_staged_file ChangeLog

  local version=`sed -ne '1s/.*(\(.*\)).*/\1/p' $filename`
  if [ "`echo $version | grep '[[:space:]]'`" != "" ]
  then
    echo "ChangeLog version contains whitespace! Fix it!"
    status=1
  fi

  set +e
  which dpkg-gencontrol > /dev/null 2>&1
  status=$?
  set -e
  if [ $status -ne 0 ]
  then
    echo "dpkg-gencontrol not found; skipping ChangeLog verification!"
    return $status
  fi

 (cd $MYTMP/files
  mkdir -p debian/tmp
  cat > debian/control <<!
Source: firehol
Section: net
Priority: optional
Homepage: http://firehol.org/
Maintainer: firehol-devs@lists.firehol.org

Package: firehol
Architecture: all
Depends: iptables
Description: firewall for humans
!
  set +e
  dpkg-gencontrol -O -pfirehol -lChangeLog > /dev/null 2> debian/tmp/l
  set -e
  status=$?
  if [ $status -eq 0 -a `grep -v "FcntlLock not available" debian/tmp/l | wc -c` -gt 0 ]
  then
    status=1
  fi
  if [ $status -ne 0 ]
  then
    cat debian/tmp/l
    touch $MYTMP/changelog.fail
  fi
 )

  if [ -f $MYTMP/changelog.fail ]; then status=1; fi
  return $status
}
