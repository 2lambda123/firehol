#!/bin/bash

PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/local/sbin

haderror=""

# We need to be able to create a new user namespace so we can be root
# in it.

userns_disabled=
if [ -f /proc/sys/kernel/unprivileged_userns_clone ]
then
  # https://github.com/bazelbuild/bazel/issues/433
  userns_disabled=$(/sbin/sysctl kernel.unprivileged_userns_clone | grep " 0$")
fi

if [ "$userns_disabled" -a "$(id -r -u)" != "0" ]
then
  echo "Must have userns enabled"
  echo ""
  echo "To fix it, try:"
  echo "  sudo sysctl kernel.unprivileged_userns_clone=1"
  haderror="Y"
fi

missing=""
for tab in mangle raw filter nat
do
  for ip in ip ip6
  do
    module="${ip}table_${tab}"
    if [ ! "$(lsmod | cut -f1 -d' ' | grep $module)" ]
    then
      test "$missing" = "" && echo "Missing module(s). Run:"
      echo "  modprobe ${module}"
      missing="Y"
      haderror="Y"
    fi
  done
done


if [ ! -x tools/clean-iptables ]
then
  echo "Executable tools/clean-iptables script not found"
  echo ""
  haderror="Y"
fi

if [ "$1" = "-inns" ]
then
  # First set up our namespace so we can write where we need to
  mount -t tmpfs tmpfs /etc/firehol
  if [ -d /var/run/firehol ]
  then
    mount -t tmpfs tmpfs /var/run/firehol
    mount -t tmpfs tmpfs /var/run/netns
  else
    mount -t tmpfs tmpfs /var/run
    mkdir /var/run/firehol
    mkdir /var/run/netns
  fi
  if [ -d /var/spool/firehol ]
  then
    mount -t tmpfs tmpfs /var/spool/firehol
  else
    mount -t tmpfs tmpfs /var/spool
    mkdir /var/spool/firehol
  fi
  mount -o rbind /sys /sys

  # Check the files are gone
  if [ -f /etc/firehol/firehol.conf \
    -o -f /etc/firehol/firehol-defaults.conf \
    -o -f /etc/firehol/fireqos.conf \
    -o -f /etc/firehol/link-balancer.conf \
    -o -d /etc/firehol/services ]
  then
    echo "Namespace switch failed! Aborting!"
    exit 1
  fi

  # /proc/net/ip_tables_names is read-only for the real root in kernels
  # up to and possibly beyond 4.1, so we may not be able to access it.
  # This file just contains the well known list of tables, depending
  # on which modules are loaded.
  # It is relied on by firehol but also by iptables-save and iptables-restore
  # We recreate the whole of proc using bind mounts, except these two files
  # which we make with our known values. We then bind our proc over the
  # original and everything just works...
  # The amazing thing being that because we are in separate user and
  # mount namespaces, none of this interferes with the running system
  # and it all runs as a regular user.
  # http://lists.linuxfoundation.org/pipermail/containers/2014-June/034682.html
  # https://lists.linuxcontainers.org/pipermail/lxc-users/2014-November/008099.html
  if [ ! -r /proc/net/ip_tables_names ]
  then
    mkdir /var/run/firehol/proc
    mkdir /var/run/firehol/proc/net
    ls /proc | while read name
    do
      case $name in
         $$)
           mkdir /var/run/firehol/proc/$name
           mount -o rbind /proc/$name /var/run/firehol/proc/$name
         ;;

         [0-9]*)
           :
         ;;

         net)
           :
         ;;

         *)
           if [ -d /proc/$name ]
           then
             mkdir /var/run/firehol/proc/$name
             mount -o rbind /proc/$name /var/run/firehol/proc/$name
           else
             touch /var/run/firehol/proc/$name
             mount -o rbind /proc/$name /var/run/firehol/proc/$name
           fi
         ;;
      esac
    done

    ls /proc/net | while read name
    do
      if [ "$name" = "ip_tables_names" -o "$name" = "ip6_tables_names" ]
      then
        echo "filter" > /var/run/firehol/proc/net/$name
        echo "nat" >> /var/run/firehol/proc/net/$name
        echo "mangle" >> /var/run/firehol/proc/net/$name
        echo "raw" >> /var/run/firehol/proc/net/$name
        chmod 444 /var/run/firehol/proc/net/$name
      elif [ -d /proc/net/$name ]
      then
        mkdir /var/run/firehol/proc/net/$name
        mount -o rbind /proc/net/$name /var/run/firehol/proc/net/$name
      else
        touch /var/run/firehol/proc/net/$name
        mount -o rbind /proc/net/$name /var/run/firehol/proc/net/$name
      fi
    done

    mount -o rbind  /var/run/firehol/proc /proc
  fi

  # Check it all worked
  cat /proc/net/ip_tables_names > /dev/null || exit 1
  mkdir /var/run/firehol/webdir || exit 1
  echo "Running in separate namespace"
  ip link add veth0 type veth peer name veth1
  shift
elif [ "$(id -r -u)" = "0" ]
then
  echo "Do not run as root. The unittest system uses user namespaces instead."
  haderror="Y"
elif [ ! "$haderror" ]
then
  echo "Unsharing namespaces"
  unshare -m -n -U -r -- $0 -inns "$@"
  exit
fi

if [ "$haderror" -o $# -lt 1 ]
then
  if [ "$haderror" ]
  then
    echo ""
    echo ""
  fi
  echo "Usage: ./unittest [--strace] all|test-dir|test-dir/test.conf [...]"
  echo ""
  echo "Example use of strace: see all non-absolute path executions:"
  echo "  grep 'execve[^,]*, \[\"[^/]' strace.*.txt | less"
  exit 1
fi

if ! MYTMP="`mktemp -d -t firehol-unittest-XXXXXX`"
then
            echo >&2
            echo >&2
            echo >&2 "Cannot create temporary directory."
            echo >&2
            exit 1
fi

ETCSAVE=/etc/firehol.save$$

myexit() {
  rm -f /var/run/firehol.lck
  rm -rf $MYTMP
  exit 0
}

trap myexit INT
trap myexit HUP
trap myexit 0

TESTDIR=`pwd`/
export TESTDIR

kcov=`which kcov 2> /dev/null`
if [ "$kcov" ]
then
  export kcov="$kcov coverage"
fi

strace=0
if [ "$1" = "--strace" ]
then
  shift
  strace=1
  STRACE_CMD=`which strace 2> /dev/null`
  if [ -z "$STRACE_CMD" ]
  then
    echo "strace not found!"
    exit 1
  fi
fi

if [ $# -eq 1 -a "$1" = "all" ]
then
  find firehol fireqos link-balancer vnetbuild -type f -name '*.conf' | sort > $MYTMP/all-tests
else
  find "$@" -type f -name '*.conf' | sort > $MYTMP/all-tests
fi

newext() {
  echo "$2" | sed -e "s;\.conf$;.$1;"
}

clear_iptables() {
  test -d $MYTMP || exit 3
  cat > $MYTMP/reset <<-!
	*raw
	:PREROUTING ACCEPT [0:0]
	:OUTPUT ACCEPT [0:0]
	COMMIT
	*nat
	:PREROUTING ACCEPT [0:0]
	:INPUT ACCEPT [0:0]
	:OUTPUT ACCEPT [0:0]
	:POSTROUTING ACCEPT [0:0]
	COMMIT
	*mangle
	:PREROUTING ACCEPT [0:0]
	:INPUT ACCEPT [0:0]
	:FORWARD ACCEPT [0:0]
	:OUTPUT ACCEPT [0:0]
	:POSTROUTING ACCEPT [0:0]
	COMMIT
	*filter
	:INPUT ACCEPT [0:0]
	:FORWARD ACCEPT [0:0]
	:OUTPUT ACCEPT [0:0]
	COMMIT
	!
  iptables-restore < $MYTMP/reset
  st1=$?

  cat > $MYTMP/reset <<-!
	*raw
	:PREROUTING ACCEPT [0:0]
	:OUTPUT ACCEPT [0:0]
	COMMIT
	*nat
	:PREROUTING ACCEPT [0:0]
	:INPUT ACCEPT [0:0]
	:OUTPUT ACCEPT [0:0]
	:POSTROUTING ACCEPT [0:0]
	COMMIT
	*mangle
	:PREROUTING ACCEPT [0:0]
	:INPUT ACCEPT [0:0]
	:FORWARD ACCEPT [0:0]
	:OUTPUT ACCEPT [0:0]
	:POSTROUTING ACCEPT [0:0]
	COMMIT
	*filter
	:INPUT ACCEPT [0:0]
	:FORWARD ACCEPT [0:0]
	:OUTPUT ACCEPT [0:0]
	COMMIT
	!
  ip6tables-restore < $MYTMP/reset
  st2=$?
  rm -f /var/run/firehol.lck

  if [ $st1 -ne 0 -o  $st2 -ne 0 ]
  then
    exit 2
  fi
}

#set -x
started=`date`
errors=0
total=0
while read conf
do
  export conf
  export pre_sh=$(newext pre.sh $conf)
  export run_sh=$(newext run.sh $conf)
  export post_sh=$(newext post.sh $conf)

  export runlog=$(newext log $conf)

  export out4=$(newext out4 $conf)
  export out6=$(newext out6 $conf)
  export aud4=$(newext aud4 $conf)
  export aud6=$(newext aud6 $conf)

  export outqdisc=$(newext qdisc.out $conf)
  export outclass=$(newext class.out $conf)
  export outfilter=$(newext filter.out $conf)
  export audqdisc=$(newext qdisc.aud $conf)
  export audclass=$(newext class.aud $conf)
  export audfilter=$(newext filter.aud $conf)

  export outrules=$(newext rules.out $conf)
  export outtable=$(newext table.out $conf)
  export audrules=$(newext rules.aud $conf)
  export audtable=$(newext table.aud $conf)

  export outns=$(newext ns.out $conf)
  export audns=$(newext ns.aud $conf)

  case $conf in
    firehol*)
      clear_iptables
      program=firehol
    ;;
    fireqos*)
      program=fireqos
    ;;
    link-balancer*)
      program=link-balancer
    ;;
    vnetbuild*)
      program=vnetbuild
    ;;
    update-ipsets*)
      program=update-ipsets
    ;;
    *)
      program=
    ;;
  esac

  if [ ! "$program" ]
  then
    echo "Cannot determine program for $conf"
  else
    script=../sbin/${program}.in
    export script
    total=$((total + 1))

    if [ $strace -eq 1 ]
    then
      export kcov="$STRACE_CMD -f -o `pwd`/strace.${total}.txt"
    fi

    # Define our configuration directory exactly as we want it
    # note: we are running in a namespace with /etc/firehol as a tmpfs
    rm -rf /etc/firehol/*

    # Default special cases:
    #  - egrep because /sbin/egrep makes use of PATH to find 'grep -E'
    #    the unit tests set PATH to empty so we must use the explicit one
    #  - logger so we get e.g. panics in our logs, not on the system console
    #  - LB_RUN_DIR + FIREQOS_LOCK_FILE + FIREQOS_DIR + RUN_PARENT_DIR
    #     keep within our mounts
    #  - PATH reset to ensure it is off (some programs reset it)
    cat > /etc/firehol/firehol-defaults.conf <<-!
		EGREP_CMD='/bin/grep -E'
		LOGGER_CMD='/bin/echo logger:'
		LB_RUN_DIR=/var/run/firehol/link-balancer
		FIREQOS_DIR=/var/run/firehol/fireqos
		FIREQOS_LOCK_FILE=/var/run/firehol/fireqos.lock
		UPDATE_IPSETS_LOCK_FILE=/var/run/firehol/update-ipsets.lock
		RUN_PARENT_DIR=/var/run/firehol
		WEB_DIR=/var/run/firehol/webdir
		export PATH=
	!

    if [ -x "$pre_sh" ]
    then
      # We can control completely with a testname.pre.sh
      "$pre_sh" "$conf"
    else
      # Or just take the defaults
      mkdir -p /etc/firehol/services
    fi

    # Run the script
    if [ -x "$run_sh" ]
    then
      # We can control completely with a testname.pre.sh
      PATH= "$run_sh" "$conf" > "$runlog" 2>&1 < /dev/null
      status=$?
    else
      # Or just take the defaults
      case $program in
        firehol|fireqos|vnetbuild)
          PATH= $kcov "$script" "$conf" start > "$runlog" 2>&1 < /dev/null
          status=$?
        ;;
        link-balancer|update-ipsets)
          cp "$conf" /etc/firehol/${program}.conf
          $kcov "$script" > "$runlog" 2>&1 < /dev/null
          status=$?
        ;;
      esac
    fi

    # If there are explicit post checks to be made, run them
    if [ $status -eq 0 -a -x "$post_sh" ]
    then
      "$post_sh" "$conf"
      status=$?
    fi

    # Compare running config to expected
    if [ $status -ne 0 ]
    then
      errors=$((errors + 1))
      echo "Unexpected run error - check $runlog"
    elif grep -q '\.in: line [0-9]*:' "$runlog"
    then
      errors=$((errors + 1))
      echo "Unexpected runtime errors - check $runlog"
    else
      case $program in
        firehol)
          iptables-save > "$out4".raw
          ip6tables-save > "$out6".raw
          tools/clean-iptables "$out4".raw > "$out4"
          tools/clean-iptables "$out6".raw > "$out6"
          if ! cmp "$aud4" "$out4"
          then
            errors=$((errors + 1))
          elif ! cmp "$aud6" "$out6"
          then
            errors=$((errors + 1))
          fi
        ;;
        fireqos)
          tc qdisc show dev veth0 > "$outqdisc"
          tc class show dev veth0 > "$outclass".raw
          tc filter show dev veth0 > "$outfilter"
          tools/clean-class "$outclass".raw > "$outclass"
          if ! cmp "$audqdisc" "$outqdisc"
          then
            errors=$((errors + 1))
          elif ! cmp "$audclass" "$outclass"
          then
            errors=$((errors + 1))
          elif ! cmp "$audfilter" "$outfilter"
          then
            errors=$((errors + 1))
          fi
        ;;
        link-balancer)
          ip rule list > "$outrules"
          for n in $(ip rule list | sed -ne 's/.*lookup //p' | sort -n)
          do
            echo "===== TABLE $n ====="
            ip route list table $n
          done > "$outtable"
          if ! cmp "$audrules" "$outrules"
          then
            errors=$((errors + 1))
          elif ! cmp "$audtable" "$outtable"
          then
            errors=$((errors + 1))
          fi
        ;;
        vnetbuild)
          ip netns list > "$outns"
          if ! cmp "$audns" "$outns"
          then
            errors=$((errors + 1))
          fi
        ;;
      esac
    fi
  fi
done < $MYTMP/all-tests

echo " Started: $started"
echo "Finished: $(date)"
echo "   Tests: ${total}"
echo "  Errors: ${errors}"
